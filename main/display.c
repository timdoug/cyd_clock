#include "display.h"
#include "config.h"
#include "driver/spi_master.h"
#include "driver/gpio.h"
#include "driver/ledc.h"
#include "esp_log.h"
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include <string.h>

static const char *TAG = "display";

// Pin definitions for ESP32-CYD
#define PIN_DC    2
#define PIN_CS    15
#define PIN_RST   4
#define PIN_MOSI  13
#define PIN_CLK   14
#define PIN_BL    21

// ILI9341 commands
#define ILI9341_NOP        0x00
#define ILI9341_SWRESET    0x01
#define ILI9341_SLPOUT     0x11
#define ILI9341_DISPON     0x29
#define ILI9341_CASET      0x2A
#define ILI9341_PASET      0x2B
#define ILI9341_RAMWR      0x2C
#define ILI9341_MADCTL     0x36
#define ILI9341_PIXFMT     0x3A

// MADCTL bits
#define MADCTL_MY  0x80
#define MADCTL_MX  0x40
#define MADCTL_MV  0x20
#define MADCTL_BGR 0x08

static spi_device_handle_t spi_dev;
static bool display_rotated = false;

// Basic 8x16 font (ASCII 32-127)
static const uint8_t font_8x16[] = {
    // Space (32)
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    // ! (33)
    0x00,0x00,0x18,0x3C,0x3C,0x3C,0x18,0x18,0x18,0x00,0x18,0x18,0x00,0x00,0x00,0x00,
    // " (34)
    0x00,0x66,0x66,0x66,0x24,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    // # (35)
    0x00,0x00,0x00,0x6C,0x6C,0xFE,0x6C,0x6C,0x6C,0xFE,0x6C,0x6C,0x00,0x00,0x00,0x00,
    // $ (36)
    0x00,0x10,0x10,0x7C,0xD6,0xD0,0x7C,0x16,0xD6,0x7C,0x10,0x10,0x00,0x00,0x00,0x00,
    // % (37)
    0x00,0x00,0x00,0x00,0xC2,0xC6,0x0C,0x18,0x30,0x66,0xC6,0x86,0x00,0x00,0x00,0x00,
    // & (38)
    0x00,0x00,0x38,0x6C,0x6C,0x38,0x76,0xDC,0xCC,0xCC,0xCC,0x76,0x00,0x00,0x00,0x00,
    // ' (39)
    0x00,0x30,0x30,0x30,0x60,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    // ( (40)
    0x00,0x00,0x0C,0x18,0x30,0x30,0x30,0x30,0x30,0x30,0x18,0x0C,0x00,0x00,0x00,0x00,
    // ) (41)
    0x00,0x00,0x30,0x18,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x18,0x30,0x00,0x00,0x00,0x00,
    // * (42)
    0x00,0x00,0x00,0x00,0x00,0x66,0x3C,0xFF,0x3C,0x66,0x00,0x00,0x00,0x00,0x00,0x00,
    // + (43)
    0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x7E,0x18,0x18,0x00,0x00,0x00,0x00,0x00,0x00,
    // , (44)
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x18,0x30,0x00,0x00,0x00,
    // - (45)
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFE,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    // . (46)
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x00,0x00,
    // / (47)
    0x00,0x00,0x00,0x00,0x02,0x06,0x0C,0x18,0x30,0x60,0xC0,0x80,0x00,0x00,0x00,0x00,
    // 0 (48)
    0x00,0x00,0x7C,0xC6,0xC6,0xCE,0xDE,0xF6,0xE6,0xC6,0xC6,0x7C,0x00,0x00,0x00,0x00,
    // 1 (49)
    0x00,0x00,0x18,0x38,0x78,0x18,0x18,0x18,0x18,0x18,0x18,0x7E,0x00,0x00,0x00,0x00,
    // 2 (50)
    0x00,0x00,0x7C,0xC6,0x06,0x0C,0x18,0x30,0x60,0xC0,0xC6,0xFE,0x00,0x00,0x00,0x00,
    // 3 (51)
    0x00,0x00,0x7C,0xC6,0x06,0x06,0x3C,0x06,0x06,0x06,0xC6,0x7C,0x00,0x00,0x00,0x00,
    // 4 (52)
    0x00,0x00,0x0C,0x1C,0x3C,0x6C,0xCC,0xFE,0x0C,0x0C,0x0C,0x1E,0x00,0x00,0x00,0x00,
    // 5 (53)
    0x00,0x00,0xFE,0xC0,0xC0,0xC0,0xFC,0x06,0x06,0x06,0xC6,0x7C,0x00,0x00,0x00,0x00,
    // 6 (54)
    0x00,0x00,0x38,0x60,0xC0,0xC0,0xFC,0xC6,0xC6,0xC6,0xC6,0x7C,0x00,0x00,0x00,0x00,
    // 7 (55)
    0x00,0x00,0xFE,0xC6,0x06,0x06,0x0C,0x18,0x30,0x30,0x30,0x30,0x00,0x00,0x00,0x00,
    // 8 (56)
    0x00,0x00,0x7C,0xC6,0xC6,0xC6,0x7C,0xC6,0xC6,0xC6,0xC6,0x7C,0x00,0x00,0x00,0x00,
    // 9 (57)
    0x00,0x00,0x7C,0xC6,0xC6,0xC6,0x7E,0x06,0x06,0x06,0x0C,0x78,0x00,0x00,0x00,0x00,
    // : (58)
    0x00,0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x00,0x00,0x00,
    // ; (59)
    0x00,0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x00,0x18,0x18,0x30,0x00,0x00,0x00,0x00,
    // < (60)
    0x00,0x00,0x00,0x06,0x0C,0x18,0x30,0x60,0x30,0x18,0x0C,0x06,0x00,0x00,0x00,0x00,
    // = (61)
    0x00,0x00,0x00,0x00,0x00,0x7E,0x00,0x00,0x7E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    // > (62)
    0x00,0x00,0x00,0x60,0x30,0x18,0x0C,0x06,0x0C,0x18,0x30,0x60,0x00,0x00,0x00,0x00,
    // ? (63)
    0x00,0x00,0x7C,0xC6,0xC6,0x0C,0x18,0x18,0x18,0x00,0x18,0x18,0x00,0x00,0x00,0x00,
    // @ (64)
    0x00,0x00,0x7C,0xC6,0xC6,0xDE,0xDE,0xDE,0xDC,0xC0,0xC0,0x7C,0x00,0x00,0x00,0x00,
    // A (65)
    0x00,0x00,0x10,0x38,0x6C,0xC6,0xC6,0xFE,0xC6,0xC6,0xC6,0xC6,0x00,0x00,0x00,0x00,
    // B (66)
    0x00,0x00,0xFC,0x66,0x66,0x66,0x7C,0x66,0x66,0x66,0x66,0xFC,0x00,0x00,0x00,0x00,
    // C (67)
    0x00,0x00,0x3C,0x66,0xC2,0xC0,0xC0,0xC0,0xC0,0xC2,0x66,0x3C,0x00,0x00,0x00,0x00,
    // D (68)
    0x00,0x00,0xF8,0x6C,0x66,0x66,0x66,0x66,0x66,0x66,0x6C,0xF8,0x00,0x00,0x00,0x00,
    // E (69)
    0x00,0x00,0xFE,0x66,0x62,0x68,0x78,0x68,0x60,0x62,0x66,0xFE,0x00,0x00,0x00,0x00,
    // F (70)
    0x00,0x00,0xFE,0x66,0x62,0x68,0x78,0x68,0x60,0x60,0x60,0xF0,0x00,0x00,0x00,0x00,
    // G (71)
    0x00,0x00,0x3C,0x66,0xC2,0xC0,0xC0,0xDE,0xC6,0xC6,0x66,0x3A,0x00,0x00,0x00,0x00,
    // H (72)
    0x00,0x00,0xC6,0xC6,0xC6,0xC6,0xFE,0xC6,0xC6,0xC6,0xC6,0xC6,0x00,0x00,0x00,0x00,
    // I (73)
    0x00,0x00,0x3C,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x3C,0x00,0x00,0x00,0x00,
    // J (74)
    0x00,0x00,0x1E,0x0C,0x0C,0x0C,0x0C,0x0C,0xCC,0xCC,0xCC,0x78,0x00,0x00,0x00,0x00,
    // K (75)
    0x00,0x00,0xE6,0x66,0x66,0x6C,0x78,0x78,0x6C,0x66,0x66,0xE6,0x00,0x00,0x00,0x00,
    // L (76)
    0x00,0x00,0xF0,0x60,0x60,0x60,0x60,0x60,0x60,0x62,0x66,0xFE,0x00,0x00,0x00,0x00,
    // M (77)
    0x00,0x00,0xC6,0xEE,0xFE,0xFE,0xD6,0xC6,0xC6,0xC6,0xC6,0xC6,0x00,0x00,0x00,0x00,
    // N (78)
    0x00,0x00,0xC6,0xE6,0xF6,0xFE,0xDE,0xCE,0xC6,0xC6,0xC6,0xC6,0x00,0x00,0x00,0x00,
    // O (79)
    0x00,0x00,0x7C,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0x7C,0x00,0x00,0x00,0x00,
    // P (80)
    0x00,0x00,0xFC,0x66,0x66,0x66,0x7C,0x60,0x60,0x60,0x60,0xF0,0x00,0x00,0x00,0x00,
    // Q (81)
    0x00,0x00,0x7C,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xD6,0xDE,0x7C,0x0C,0x0E,0x00,0x00,
    // R (82)
    0x00,0x00,0xFC,0x66,0x66,0x66,0x7C,0x6C,0x66,0x66,0x66,0xE6,0x00,0x00,0x00,0x00,
    // S (83)
    0x00,0x00,0x7C,0xC6,0xC6,0x60,0x38,0x0C,0x06,0xC6,0xC6,0x7C,0x00,0x00,0x00,0x00,
    // T (84)
    0x00,0x00,0xFF,0xDB,0x99,0x18,0x18,0x18,0x18,0x18,0x18,0x3C,0x00,0x00,0x00,0x00,
    // U (85)
    0x00,0x00,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0x7C,0x00,0x00,0x00,0x00,
    // V (86)
    0x00,0x00,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0x6C,0x38,0x10,0x00,0x00,0x00,0x00,
    // W (87)
    0x00,0x00,0xC6,0xC6,0xC6,0xC6,0xD6,0xD6,0xD6,0xFE,0xEE,0x6C,0x00,0x00,0x00,0x00,
    // X (88)
    0x00,0x00,0xC6,0xC6,0x6C,0x7C,0x38,0x38,0x7C,0x6C,0xC6,0xC6,0x00,0x00,0x00,0x00,
    // Y (89)
    0x00,0x00,0xC6,0xC6,0xC6,0x6C,0x38,0x18,0x18,0x18,0x18,0x3C,0x00,0x00,0x00,0x00,
    // Z (90)
    0x00,0x00,0xFE,0xC6,0x86,0x0C,0x18,0x30,0x60,0xC2,0xC6,0xFE,0x00,0x00,0x00,0x00,
    // [ (91)
    0x00,0x00,0x3C,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x3C,0x00,0x00,0x00,0x00,
    // \ (92)
    0x00,0x00,0x00,0x80,0xC0,0xE0,0x70,0x38,0x1C,0x0E,0x06,0x02,0x00,0x00,0x00,0x00,
    // ] (93)
    0x00,0x00,0x3C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x3C,0x00,0x00,0x00,0x00,
    // ^ (94)
    0x00,0x10,0x38,0x6C,0xC6,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    // _ (95)
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x00,0x00,
    // ` (96)
    0x00,0x30,0x30,0x18,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    // a (97)
    0x00,0x00,0x00,0x00,0x00,0x78,0x0C,0x7C,0xCC,0xCC,0xCC,0x76,0x00,0x00,0x00,0x00,
    // b (98)
    0x00,0x00,0xE0,0x60,0x60,0x78,0x6C,0x66,0x66,0x66,0x66,0x7C,0x00,0x00,0x00,0x00,
    // c (99)
    0x00,0x00,0x00,0x00,0x00,0x7C,0xC6,0xC0,0xC0,0xC0,0xC6,0x7C,0x00,0x00,0x00,0x00,
    // d (100)
    0x00,0x00,0x1C,0x0C,0x0C,0x3C,0x6C,0xCC,0xCC,0xCC,0xCC,0x76,0x00,0x00,0x00,0x00,
    // e (101)
    0x00,0x00,0x00,0x00,0x00,0x7C,0xC6,0xFE,0xC0,0xC0,0xC6,0x7C,0x00,0x00,0x00,0x00,
    // f (102)
    0x00,0x00,0x1C,0x36,0x32,0x30,0x78,0x30,0x30,0x30,0x30,0x78,0x00,0x00,0x00,0x00,
    // g (103)
    0x00,0x00,0x00,0x00,0x00,0x76,0xCC,0xCC,0xCC,0xCC,0xCC,0x7C,0x0C,0xCC,0x78,0x00,
    // h (104)
    0x00,0x00,0xE0,0x60,0x60,0x6C,0x76,0x66,0x66,0x66,0x66,0xE6,0x00,0x00,0x00,0x00,
    // i (105)
    0x00,0x00,0x18,0x18,0x00,0x38,0x18,0x18,0x18,0x18,0x18,0x3C,0x00,0x00,0x00,0x00,
    // j (106)
    0x00,0x00,0x06,0x06,0x00,0x0E,0x06,0x06,0x06,0x06,0x06,0x06,0x66,0x66,0x3C,0x00,
    // k (107)
    0x00,0x00,0xE0,0x60,0x60,0x66,0x6C,0x78,0x78,0x6C,0x66,0xE6,0x00,0x00,0x00,0x00,
    // l (108)
    0x00,0x00,0x38,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x3C,0x00,0x00,0x00,0x00,
    // m (109)
    0x00,0x00,0x00,0x00,0x00,0xEC,0xFE,0xD6,0xD6,0xD6,0xD6,0xC6,0x00,0x00,0x00,0x00,
    // n (110)
    0x00,0x00,0x00,0x00,0x00,0xDC,0x66,0x66,0x66,0x66,0x66,0x66,0x00,0x00,0x00,0x00,
    // o (111)
    0x00,0x00,0x00,0x00,0x00,0x7C,0xC6,0xC6,0xC6,0xC6,0xC6,0x7C,0x00,0x00,0x00,0x00,
    // p (112)
    0x00,0x00,0x00,0x00,0x00,0xDC,0x66,0x66,0x66,0x66,0x66,0x7C,0x60,0x60,0xF0,0x00,
    // q (113)
    0x00,0x00,0x00,0x00,0x00,0x76,0xCC,0xCC,0xCC,0xCC,0xCC,0x7C,0x0C,0x0C,0x1E,0x00,
    // r (114)
    0x00,0x00,0x00,0x00,0x00,0xDC,0x76,0x66,0x60,0x60,0x60,0xF0,0x00,0x00,0x00,0x00,
    // s (115)
    0x00,0x00,0x00,0x00,0x00,0x7C,0xC6,0x60,0x38,0x0C,0xC6,0x7C,0x00,0x00,0x00,0x00,
    // t (116)
    0x00,0x00,0x10,0x30,0x30,0xFC,0x30,0x30,0x30,0x30,0x36,0x1C,0x00,0x00,0x00,0x00,
    // u (117)
    0x00,0x00,0x00,0x00,0x00,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0x76,0x00,0x00,0x00,0x00,
    // v (118)
    0x00,0x00,0x00,0x00,0x00,0xC6,0xC6,0xC6,0xC6,0xC6,0x6C,0x38,0x00,0x00,0x00,0x00,
    // w (119)
    0x00,0x00,0x00,0x00,0x00,0xC6,0xC6,0xD6,0xD6,0xD6,0xFE,0x6C,0x00,0x00,0x00,0x00,
    // x (120)
    0x00,0x00,0x00,0x00,0x00,0xC6,0x6C,0x38,0x38,0x38,0x6C,0xC6,0x00,0x00,0x00,0x00,
    // y (121)
    0x00,0x00,0x00,0x00,0x00,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0x7E,0x06,0x0C,0xF8,0x00,
    // z (122)
    0x00,0x00,0x00,0x00,0x00,0xFE,0xCC,0x18,0x30,0x60,0xC6,0xFE,0x00,0x00,0x00,0x00,
    // { (123)
    0x00,0x00,0x0E,0x18,0x18,0x18,0x70,0x18,0x18,0x18,0x18,0x0E,0x00,0x00,0x00,0x00,
    // | (124)
    0x00,0x00,0x18,0x18,0x18,0x18,0x00,0x18,0x18,0x18,0x18,0x18,0x00,0x00,0x00,0x00,
    // } (125)
    0x00,0x00,0x70,0x18,0x18,0x18,0x0E,0x18,0x18,0x18,0x18,0x70,0x00,0x00,0x00,0x00,
    // ~ (126)
    0x00,0x00,0x76,0xDC,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    // degree (127)
    0x00,0x18,0x24,0x24,0x18,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
};

// 7-segment patterns for digits 0-9 and dash
// Segments: bit 0=top, 1=top-right, 2=bottom-right, 3=bottom, 4=bottom-left, 5=top-left, 6=middle
static const uint8_t seg7_patterns[11] = {
    0b00111111, // 0
    0b00000110, // 1
    0b01011011, // 2
    0b01001111, // 3
    0b01100110, // 4
    0b01101101, // 5
    0b01111100, // 6 (no top)
    0b00000111, // 7
    0b01111111, // 8
    0b01100111, // 9 (no bottom)
    0b01000000, // 10 = dash (middle segment only)
};

static void dc_command(void) {
    gpio_set_level(PIN_DC, 0);
}

static void dc_data(void) {
    gpio_set_level(PIN_DC, 1);
}

static void spi_write_byte(uint8_t data) {
    spi_transaction_t t = {
        .length = 8,
        .tx_buffer = &data,
    };
    spi_device_polling_transmit(spi_dev, &t);
}

static void spi_write_bytes(const uint8_t *data, size_t len) {
    if (len == 0) return;
    spi_transaction_t t = {
        .length = len * 8,
        .tx_buffer = data,
    };
    spi_device_polling_transmit(spi_dev, &t);
}

static void write_command(uint8_t cmd) {
    dc_command();
    spi_write_byte(cmd);
}

static void write_data(uint8_t data) {
    dc_data();
    spi_write_byte(data);
}

static void set_addr_window(int16_t x, int16_t y, int16_t w, int16_t h) {
    write_command(ILI9341_CASET);
    dc_data();
    uint8_t ca[] = {(uint8_t)(x >> 8), (uint8_t)x, (uint8_t)((x + w - 1) >> 8), (uint8_t)(x + w - 1)};
    spi_write_bytes(ca, 4);

    write_command(ILI9341_PASET);
    dc_data();
    uint8_t pa[] = {(uint8_t)(y >> 8), (uint8_t)y, (uint8_t)((y + h - 1) >> 8), (uint8_t)(y + h - 1)};
    spi_write_bytes(pa, 4);

    write_command(ILI9341_RAMWR);
}

void display_init(void) {
    ESP_LOGI(TAG, "Initializing display");

    // Configure GPIO
    gpio_config_t io_conf = {
        .pin_bit_mask = (1ULL << PIN_DC) | (1ULL << PIN_RST),
        .mode = GPIO_MODE_OUTPUT,
        .pull_up_en = GPIO_PULLUP_DISABLE,
        .pull_down_en = GPIO_PULLDOWN_DISABLE,
        .intr_type = GPIO_INTR_DISABLE,
    };
    gpio_config(&io_conf);

    // Hardware reset
    gpio_set_level(PIN_RST, 0);
    vTaskDelay(pdMS_TO_TICKS(100));
    gpio_set_level(PIN_RST, 1);
    vTaskDelay(pdMS_TO_TICKS(100));

    // Initialize SPI bus
    spi_bus_config_t buscfg = {
        .mosi_io_num = PIN_MOSI,
        .miso_io_num = -1,
        .sclk_io_num = PIN_CLK,
        .quadwp_io_num = -1,
        .quadhd_io_num = -1,
        .max_transfer_sz = DISPLAY_WIDTH * DISPLAY_HEIGHT * 2,
    };
    ESP_ERROR_CHECK(spi_bus_initialize(SPI2_HOST, &buscfg, SPI_DMA_CH_AUTO));

    // Add SPI device
    spi_device_interface_config_t devcfg = {
        .clock_speed_hz = SPI_CLOCK_HZ,
        .mode = 0,
        .spics_io_num = PIN_CS,
        .queue_size = 7,
    };
    ESP_ERROR_CHECK(spi_bus_add_device(SPI2_HOST, &devcfg, &spi_dev));

    // Initialize ILI9341
    write_command(ILI9341_SWRESET);
    vTaskDelay(pdMS_TO_TICKS(150));

    write_command(ILI9341_SLPOUT);
    vTaskDelay(pdMS_TO_TICKS(150));

    write_command(ILI9341_PIXFMT);
    write_data(0x55);  // 16-bit color

    write_command(ILI9341_MADCTL);
    write_data(MADCTL_MV | MADCTL_BGR);  // Landscape mode

    write_command(ILI9341_DISPON);
    vTaskDelay(pdMS_TO_TICKS(100));

    // Setup backlight PWM
    ledc_timer_config_t ledc_timer = {
        .speed_mode = LEDC_LOW_SPEED_MODE,
        .timer_num = LEDC_TIMER_0,
        .duty_resolution = LEDC_TIMER_8_BIT,
        .freq_hz = PWM_FREQUENCY_HZ,
        .clk_cfg = LEDC_AUTO_CLK,
    };
    ledc_timer_config(&ledc_timer);

    ledc_channel_config_t ledc_channel = {
        .speed_mode = LEDC_LOW_SPEED_MODE,
        .channel = LEDC_CHANNEL_0,
        .timer_sel = LEDC_TIMER_0,
        .intr_type = LEDC_INTR_DISABLE,
        .gpio_num = PIN_BL,
        .duty = 128,
        .hpoint = 0,
    };
    ledc_channel_config(&ledc_channel);

    display_fill(COLOR_BLACK);
    ESP_LOGI(TAG, "Display initialized");
}

void display_fill(uint16_t color) {
    display_fill_rect(0, 0, DISPLAY_WIDTH, DISPLAY_HEIGHT, color);
}

void display_fill_rect(int16_t x, int16_t y, int16_t w, int16_t h, uint16_t color) {
    if (x >= DISPLAY_WIDTH || y >= DISPLAY_HEIGHT || w <= 0 || h <= 0) return;
    if (x < 0) { w += x; x = 0; }
    if (y < 0) { h += y; y = 0; }
    if (x + w > DISPLAY_WIDTH) w = DISPLAY_WIDTH - x;
    if (y + h > DISPLAY_HEIGHT) h = DISPLAY_HEIGHT - y;

    set_addr_window(x, y, w, h);
    dc_data();

    uint8_t hi = color >> 8;
    uint8_t lo = color & 0xFF;

    // Use a buffer for faster filling
    static uint8_t buf[512];
    for (int i = 0; i < 256; i++) {
        buf[i * 2] = hi;
        buf[i * 2 + 1] = lo;
    }

    int32_t total = (int32_t)w * h;
    while (total > 0) {
        int chunk = (total > 256) ? 256 : total;
        spi_write_bytes(buf, chunk * 2);
        total -= chunk;
    }
}

void display_pixel(int16_t x, int16_t y, uint16_t color) {
    if (x < 0 || x >= DISPLAY_WIDTH || y < 0 || y >= DISPLAY_HEIGHT) return;
    set_addr_window(x, y, 1, 1);
    dc_data();
    uint8_t data[] = {(uint8_t)(color >> 8), (uint8_t)color};
    spi_write_bytes(data, 2);
}

void display_hline(int16_t x, int16_t y, int16_t w, uint16_t color) {
    display_fill_rect(x, y, w, 1, color);
}

void display_vline(int16_t x, int16_t y, int16_t h, uint16_t color) {
    display_fill_rect(x, y, 1, h, color);
}

void display_rect(int16_t x, int16_t y, int16_t w, int16_t h, uint16_t color) {
    display_hline(x, y, w, color);
    display_hline(x, y + h - 1, w, color);
    display_vline(x, y, h, color);
    display_vline(x + w - 1, y, h, color);
}

void display_char(int16_t x, int16_t y, char c, uint16_t fg, uint16_t bg) {
    if (c < 32 || c > 127) c = '?';
    const uint8_t *glyph = &font_8x16[(c - 32) * 16];

    set_addr_window(x, y, 8, 16);
    dc_data();

    uint8_t buf[256];  // 8 * 16 * 2 = 256 bytes
    int idx = 0;
    for (int row = 0; row < 16; row++) {
        uint8_t bits = glyph[row];
        for (int col = 0; col < 8; col++) {
            uint16_t color = (bits & 0x80) ? fg : bg;
            buf[idx++] = color >> 8;
            buf[idx++] = color & 0xFF;
            bits <<= 1;
        }
    }
    spi_write_bytes(buf, 256);
}

void display_string(int16_t x, int16_t y, const char *str, uint16_t fg, uint16_t bg) {
    while (*str) {
        display_char(x, y, *str++, fg, bg);
        x += 8;
    }
}

// Blend two RGB565 colors (simple average)
static uint16_t blend_color(uint16_t c1, uint16_t c2) {
    uint16_t r = (((c1 >> 11) & 0x1F) + ((c2 >> 11) & 0x1F)) >> 1;
    uint16_t g = (((c1 >> 5) & 0x3F) + ((c2 >> 5) & 0x3F)) >> 1;
    uint16_t b = ((c1 & 0x1F) + (c2 & 0x1F)) >> 1;
    return (r << 11) | (g << 5) | b;
}

// Get pixel from glyph (returns 1 if set, 0 if not, handles bounds)
static inline int get_glyph_pixel(const uint8_t *glyph, int row, int col) {
    if (row < 0 || row >= 16 || col < 0 || col >= 8) return 0;
    return (glyph[row] >> (7 - col)) & 1;
}

static void display_char_2x(int16_t x, int16_t y, char c, uint16_t fg, uint16_t bg) {
    if (c < 32 || c > 127) c = '?';
    const uint8_t *glyph = &font_8x16[(c - 32) * 16];
    uint16_t smooth = blend_color(fg, bg);

    set_addr_window(x, y, 16, 32);
    dc_data();

    uint8_t buf[1024];  // 16 * 32 * 2 = 1024 bytes
    int idx = 0;

    for (int row = 0; row < 16; row++) {
        for (int dup = 0; dup < 2; dup++) {  // Each source row becomes 2 output rows
            for (int col = 0; col < 8; col++) {
                int cur = get_glyph_pixel(glyph, row, col);
                uint16_t base_color = cur ? fg : bg;

                // Get neighbors for corner smoothing
                int above = get_glyph_pixel(glyph, row - 1, col);
                int below = get_glyph_pixel(glyph, row + 1, col);
                int left = get_glyph_pixel(glyph, row, col - 1);
                int right = get_glyph_pixel(glyph, row, col + 1);

                // For each source pixel, we output 2 pixels (left and right)
                uint16_t left_color = base_color;
                uint16_t right_color = base_color;

                if (cur) {
                    // Current pixel is ON - check for smoothing at corners
                    int above_left = get_glyph_pixel(glyph, row - 1, col - 1);
                    int above_right = get_glyph_pixel(glyph, row - 1, col + 1);
                    int below_left = get_glyph_pixel(glyph, row + 1, col - 1);
                    int below_right = get_glyph_pixel(glyph, row + 1, col + 1);

                    if (dup == 0) {
                        // Top half - check top corners
                        if (!above_left && !above && !left) left_color = smooth;
                        if (!above_right && !above && !right) right_color = smooth;
                    } else {
                        // Bottom half - check bottom corners
                        if (!below_left && !below && !left) left_color = smooth;
                        if (!below_right && !below && !right) right_color = smooth;
                    }
                }

                buf[idx++] = left_color >> 8;
                buf[idx++] = left_color & 0xFF;
                buf[idx++] = right_color >> 8;
                buf[idx++] = right_color & 0xFF;
            }
        }
    }
    spi_write_bytes(buf, 1024);
}

void display_string_2x(int16_t x, int16_t y, const char *str, uint16_t fg, uint16_t bg) {
    while (*str) {
        display_char_2x(x, y, *str++, fg, bg);
        x += 16;
    }
}

// Draw a single 7-segment element (horizontal or vertical bar)
static void draw_segment_h(int16_t x, int16_t y, int16_t w, int16_t thick, uint16_t color) {
    // Horizontal segment with pointed ends
    for (int t = 0; t < thick; t++) {
        int inset = (t < thick / 2) ? (thick / 2 - t) : (t - thick / 2);
        display_hline(x + inset, y + t, w - 2 * inset, color);
    }
}

static void draw_segment_v(int16_t x, int16_t y, int16_t h, int16_t thick, uint16_t color) {
    // Vertical segment with pointed ends
    for (int t = 0; t < thick; t++) {
        int inset = (t < thick / 2) ? (thick / 2 - t) : (t - thick / 2);
        display_vline(x + t, y + inset, h - 2 * inset, color);
    }
}

void display_digit_7seg(int16_t x, int16_t y, uint8_t digit, uint8_t size, uint16_t color, uint16_t bg) {
    if (digit > 10) return;

    // Size multipliers
    int16_t seg_len, seg_thick, gap;
    switch (size) {
        case 1: seg_len = 16; seg_thick = 4; gap = 1; break;
        case 2: seg_len = 32; seg_thick = 6; gap = 2; break;
        case 3:
        default: seg_len = 48; seg_thick = 8; gap = 2; break;
    }

    uint8_t pattern = seg7_patterns[digit];

    // All segments shortened by gap and positioned with gaps between them
    int16_t h_len = seg_len - gap * 2;  // Horizontal segments shorter
    int16_t v_len = seg_len - gap;       // Vertical segments shorter

    // Draw all segments - on segments in color, off segments in bg (no flash)
    // Segment 0: top horizontal
    draw_segment_h(x + seg_thick / 2 + gap, y, h_len, seg_thick, (pattern & 0x01) ? color : bg);

    // Segment 1: top-right vertical
    draw_segment_v(x + seg_len, y + seg_thick / 2 + gap, v_len, seg_thick, (pattern & 0x02) ? color : bg);

    // Segment 2: bottom-right vertical
    draw_segment_v(x + seg_len, y + seg_len + seg_thick / 2 + gap * 2 + 1, v_len, seg_thick, (pattern & 0x04) ? color : bg);

    // Segment 3: bottom horizontal
    draw_segment_h(x + seg_thick / 2 + gap, y + seg_len * 2 + seg_thick - 1, h_len, seg_thick, (pattern & 0x08) ? color : bg);

    // Segment 4: bottom-left vertical
    draw_segment_v(x, y + seg_len + seg_thick / 2 + gap * 2 + 1, v_len, seg_thick, (pattern & 0x10) ? color : bg);

    // Segment 5: top-left vertical
    draw_segment_v(x, y + seg_thick / 2 + gap, v_len, seg_thick, (pattern & 0x20) ? color : bg);

    // Segment 6: middle horizontal
    draw_segment_h(x + seg_thick / 2 + gap, y + seg_len + seg_thick / 2 - 1, h_len, seg_thick, (pattern & 0x40) ? color : bg);
}

void display_colon_7seg(int16_t x, int16_t y, uint8_t size, uint16_t color, uint16_t bg) {
    int16_t seg_len, seg_thick, dot_size;
    switch (size) {
        case 1: seg_len = 16; seg_thick = 4; dot_size = 4; break;
        case 2: seg_len = 32; seg_thick = 6; dot_size = 6; break;
        case 3:
        default: seg_len = 48; seg_thick = 8; dot_size = 8; break;
    }

    // Draw dots directly in color (no background clear to avoid flash)
    // Upper dot
    display_fill_rect(x + 2, y + seg_len / 2 + seg_thick / 2, dot_size, dot_size, color);

    // Lower dot
    display_fill_rect(x + 2, y + seg_len + seg_len / 2 + seg_thick, dot_size, dot_size, color);
}

void display_set_backlight(uint8_t brightness) {
    uint8_t corrected = gamma_correct(brightness);
    ledc_set_duty(LEDC_LOW_SPEED_MODE, LEDC_CHANNEL_0, corrected);
    ledc_update_duty(LEDC_LOW_SPEED_MODE, LEDC_CHANNEL_0);
}

void display_set_rotation(bool rotated) {
    display_rotated = rotated;
    write_command(ILI9341_MADCTL);
    if (rotated) {
        write_data(MADCTL_MV | MADCTL_MY | MADCTL_MX | MADCTL_BGR);
    } else {
        write_data(MADCTL_MV | MADCTL_BGR);
    }
}

bool display_is_rotated(void) {
    return display_rotated;
}
